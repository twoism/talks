State of Go
Lyft Seattle

Christopher Burnett, Chris Roche
Core Libraries

* State of Go

* History

* Why Go?

* Why Go?

- Type safety
- Concurrency
- Simplicity
- Speed

* Type Safety

- Eliminates entire class of errors
- Browsability - IDEs
- Reasonability

* Concurrency

- First class citizen
- Simply model (routines & channels)
- Built in race detection

* Simplicity

- No generics (Sorry)
- Robust standard lib (http/2, context, io)
- Opinionated (gofmt, lint)

* What's missing?

- NumPy, SciPy
- Mature ML

* Go at Lyft

- ~7 Services
- Odie (MongoDB & DynamoDB ODM)
- SRV (gRPC & HTTP Framework)
- protoc-gen-service (IDL based service generator)
- protoc-gen-lyftgo (protoc plugin framework)

* Where to start?

Getting Started with Go

.link https://docs.google.com/document/d/1bBkI-03w6uhNXF-zZ_tKg4QIVPeAiAGLK1xmd7MyHco

protoc-gen-service

.link https://docs.google.com/document/d/1YncWZqiO76taFe07SvqbjRhc0_pHmdwCCUCbyc7XrIQ

SRV Docs

.link https://github.com/lyft/srv

Odie Docs

.link https://github.com/lyft/odie


* Protocol Buffers, gRPC, Versions, Oh My!

* Protocol Buffers

* Protocol Buffers

- Google IDL (see: Thrift, JSON Schema, Avro)
- Binary serializable
- Strict types
- Backwards/Forwards compatibility
- NOT self-describing

*Features*

- Strings, Binary, Integers, Floats, Boolean, Maps, Arrays
- enums (integers only)
- composition (embedded types)
- unions (via `oneof`)
- nesting

* Proto2 (2008)

- First public version of PBs
- Optional vs Required fields
- Exposes extensions API

  syntax = "proto2";

  package pb.lyft.records;

  import "pb/lyft/widgets/gizmo.proto";

  message Record {
      required uint64        id    = 1;
      optional string        label = 2;
      optional widgets.Gizmo gizmo = 3;
  }

.link https://developers.google.com/protocol-buffers/docs/proto

* Proto3 (2016)

- Optional only
- Zero value defaults
- Incompatible `enum` implementations with proto2

  syntax = "proto3";

  package pb.lyft.records;

  import "pb/lyft/widgets/gizmo.proto";

  message Record {
      uint64        id    = 1;
      string        label = 2;
      widgets.Gizmo gizmo = 3;
  }

.link https://developers.google.com/protocol-buffers/docs/proto3

* Extensions

- Modify the fields of an unowned protobuf
- Think monkey patching (don't) or meta-programming (do)
- Options: metadata for any facet of a proto file

  # proto/ext/odie.proto

  extend google.protobuf.MessageOptions {
    optional bool model = 89132;
  }

  # proto/lyft/record.proto

  import "proto/ext/odie.proto"

  message Record {
    option (odie.model) = true;

    required uint64        id    = 1 [(odie.mongo_attr).name = "_id"];
    optional string        label = 2;
  }

* Protoc

* Protoc

- Protocol buffer compiler
- Parses *.proto files into descriptors
- All dependencies and syntactic validation
- (which are actually PB Messages themselves)
- Doesn't know what to do with them
- Versioned independently of syntax and libraries

* Protoc Plugins

- `protoc-gen-*`
- Receives serialized descriptors via `stdin`
- Responds with files to generate on `stdout`

*Plugins*We*Use*

- python (Official)
- client (Flask gRPC clients)
- lyftgo (Official Go + Envoy aware gRPC clients)
- odie (Odie models and repos)
- php2 (Unofficial, only one that supports proto2)
- doctrine (Decomp of core services)

* Execution

  protoc \
      -I . \
      -lyftgo_out="plugins=grpc+envoy:../generated/go" \
      -odie_out="plugins=odie:../generated/go" \
      ./*.proto

* Python/PHP/Go Protobuf Library

* Python/PHP/Go Protobuf Library

- Shared code for handling protocol buffers
- Dependency of the generated code
- Versioned independently of protoc and syntax
- Python: pure python (slow) or native bindings (fast)
- PHP: C-based PHP module extension
- Go: pure Go implementation

* gRPC

* gRPC

- Transport mechanism for Protocol Buffers
- Type safety at service boundaries
- Implemented on top of HTTP/2
- Unary and Streaming endpoints
- Extensible through options and interceptors
- Path based, but not REST-ful

  service Manager {
    rpc Create (CreateRequest) returns (CreateResponse) {}
    rpc Suspend (SuspendRequest) returns (SuspendResponse) {}
    rpc Resume (ResumeRequest) returns (ResumeResponse) {}
    rpc SetPrivileges (SetPrivilegesRequest) returns (SetPrivilegesResponse) {}
    rpc Invalidate (InvalidateRequest) returns (InvalidateResponse) {}
    rpc Get (GetRequest) returns (GetResponse) {}
  }

* gRPC Server

Implement Service Interface

  type ManagerServer interface {
    Create(context.Context, *CreateRequest) (*CreateResponse, error)
    Suspend(context.Context, *SuspendRequest) (*SuspendResponse, error)
    Resume(context.Context, *ResumeRequest) (*ResumeResponse, error)
    SetPrivileges(context.Context, *SetPrivilegesRequest) (*SetPrivilegesResponse, error)
    Invalidate(context.Context, *InvalidateRequest) (*InvalidateResponse, error)
    Get(context.Context, *GetRequest) (*GetResponse, error)
  }

Boot Server & Register Service

  server := grpc.NewServer()
  auth.RegisterManagerServer(server, &MyCMS{})

  lis, err := net.Listen("tcp", ":8081")
  checkErr(err)

  server.Serve(lis)

* gRPC Client

Dial Server & Instantiate Client

  conn, err := grpc.Dial(":8081")
  checkErr(err)

  cl := auth.NewManagerClient(conn)

  res, err := cl.Get(context.TODO(), &GetRequest{"my-fancy-client"})
  checkErr(err)

  // res == *auth.GetResponse{ ... }

Envoy Aware Clients

  envoy := fmt.Sprintf(":%s", os.GetEnv("ENVOY_PORT"))

  cl, err := auth.NewEnvoyManagerClient(envoy, "auth")
  checkErr(err)

  res, err := cl.Get(...)

* gRPC Response Codes

- Always 200 HTTP Response Code
- gRPC Codes Exposed in returned error

  OK                 Code =  0
  Canceled           Code =  1
  Unknown            Code =  2
  InvalidArgument    Code =  3
  DeadlineExceeded   Code =  4
  NotFound           Code =  5
  AlreadyExists      Code =  6
  PermissionDenied   Code =  7
  ResourceExhausted  Code =  8
  FailedPrecondition Code =  9
  Aborted            Code = 10
  OutOfRange         Code = 11
  Unimplemented      Code = 12
  Internal           Code = 13
  Unavailable        Code = 14
  DataLoss           Code = 15
  Unauthenticated    Code = 16

.link https://godoc.org/google.golang.org/grpc/codes

* Odie

* Odie

*Driver-agnostic*ODM*For*Go*

- Object-Document Mapper
- Supports: MongoDB and DynamoDB
- Hackathon: BoltDB (thanks, @rcox!)
- Future: CockroachDB and/or Spanner

*Protocol*Buffer*Based*Schema*

- Build type-safe models and repositories
- Schema validation
- Serializable (`ToProto` / `ToModel`)
- Uses extensions for customization

* Odie: Architecture

- Expressions (Fluent Builder & Driver-Specific Marshalers)
- Action Builders (Fluent, Type-Unsafe, Driver-Specific)
- Clients (Driver-Specific)
- Decorators (Modify Actions)
- Odie Models or any types as input
- Repos (Fluent, Type-Safe, Driver-Specific)

* Odie: Schema

  syntax = "proto3";

  package pb.lyft.records;

  import "pb/ext/odie/odie.proto";
  import "pb/lyft/widgets/gizmo.proto";

  message Record {
      option (odie.mongo_repo).enabled = true;

      uint64        id    = 1 [ (odie.mongo_attr).primary_key = true,
                                (odie.type).object_id         = true ];

      string        label = 2 [ (odie.mongo_attr).omit_if_empty = true ];

      widgets.Gizmo gizmo = 3 [ (odie.mongo_attr).name = "gadget" ];
  }

* Odie: Model & Repo

Models are ordinary structs

  type RecordModel struct {
    o *RecordModel

    Id    bson.ObjectID
    Label string              `bson:",omit_empty"`
    Gizmo *widgets.GizmoModel `bson:"gadget"`
  }

Repository is type-aware

  type IFace interface {
  	Events() *Events
  	Get(ctx context.Context, id bson.ObjectID) *GetBuilder
  	Put(ctx context.Context, target *RecordModel) *PutBuilder
  	Delete(ctx context.Context) *DeleteBuilder
  	Update(ctx context.Context) *UpdateBuilder
  	Query(ctx context.Context) *QueryBuilder
  }

* Odie: Example Usage

Get

  var rec RecordModel
  id := bson.ObjectIdHex("deadb33f")
  err := repo.Get(ctx, id).Into(&rec).Response()

Update

  rec.Label = "this is my new label"
  err = repo.Update(ctx).Into(&rec).Response()

Query

  var recs []RecordModel
  err = repo.Query(ctx).Into(&recs).
    Offset(100).Limit(20).
    Where().Attr("label").Exists().
    Response()

* Odie: More Features

- Put / Get / Update / Query / Scan / Delete / Count
- Upsert vs Insert vs FindAndModify
- Lifecycle Hooks
- Change Set Tracking & Partial Updates
- Polymorphic Fields
- Optimistic & Pessimistic Locking
- Inlining support (even on polymorphic fields)

* SRV

* SRV

.link http://github.com/lyft/srv

- gRPC & HTTP framework
- Middleware extensible
- Production ready (Stats, Runtime, Logger)

* Defining a service

	message Driver {
		option (odie.dynamo_repo).enabled = true;
		uint64 id                    = 1 [(odie.dynamo_attr).primary = true];
		uint64 activeVehicleId       = 2;
		int64 lastUpdatedTimestamp   = 3 [(odie.type).date_time = true];
	}

	service Drivers {
		rpc Get (GetRequest) returns (GetResponse) {}
		rpc GetFromSupply (GetRequest) returns (GetSupplyResponse) {}
		rpc Create (CreateRequest) returns (CreateResponse) {}
		rpc Update (UpdateRequest) returns (UpdateResponse) {}
	}

* gRPC Implementation

	type DriversServer interface {
		Get(context.Context, *GetRequest) (*GetResponse, error)
		GetFromSupply(context.Context, *GetRequest) (*GetSupplyResponse, error)
		Create(context.Context, *CreateRequest) (*CreateResponse, error)
		Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	}

* Building a service

	package main

	func main() {
		srv, err := server.New(config.New())

		if err != nil {
			panic(err)
		}

		drv := drivers_service.New(drivers_config.New())
		srv.RegisterGRPC(drv)

		srv.Get("/api/1/drivers").WithStat("get.drivers").WithHandler(func(*cfg.Config) http.HandlerFunc {
			return func(w http.ResponseWriter, req *http.Request) {
				w.WriteHeader(http.StatusOK)
			}
		})

		err = srv.Serve()

		if err != nil {
			panic(err)
		}
	}

* What's in a Config?

	// Base Config
	type IFace interface {
		Env() env.Settings
		Runtime() runtime.Snapshot
		Logger() logger.Logger
		Meta() *Meta
		Scope() stats.Scope
	}

	// Server Config
	type IFace interface {
		config.IFace
		HttpConfig() *http.Config
		GrpcConfig() *grpc.Config
	}

	// App Config
	type IFace interface {
		config.IFace
		DynamoDbDriverRepo() driver_dynamodb_repo.IFace
		DynamoDbVehicleRepo() vehicle_dynamodb_repo.IFace
	}

* protoc-gen-service

* protoc-gen-service

- protoc plugin
- IDL based service generation
- Prescriptive design pattern
- Encourages testable boundaries

* Why build this?

- Reducing config copy pasta
- Consistent project structure
- Time to running Devbox image (~5mins)

* Generating a service

	$ script/gen-service supply

.image pgs.png 550 _

* What's included?

- Preconfigured Odie's
- gRPC CLI
- Devbox integration
- Repositories with Mocks
- Tests, tests, and more tests

* Project Layout

	├── Dockerfile
	├── Makefile
	├── OWNERS
	├── README.md
	├── cli
	├── config
	├── glide.yaml
	├── infra
	├── main.go
	├── manifest.yaml
	├── ops
	├── repositories
	├── script
	└── services

* Repositories

	├── repositories
	└── dynamodb
		├── driver
		│   ├── driver_repo.go
		│   ├── driver_repo_test.go
		│   └── events
		└── vehicle
			├── events
			├── vehicle_repo.go
			└── vehicle_repo_test.go

* Repositories

- Handle business logic
- Encapsulate queries
- Easily Mocked
- Meant to be extended

* Repositories

The generated CRUD IFace.

	type IFace interface {
		GetByID(context.Context, uint64) (*models.UserModel, error)
		DeleteByID(context.Context, uint64) error
		Upsert(context.Context, *models.UserModel) (uint64, error)
	}

* Repositories

	func New(repo repo.IFace) (r *Repo) {
		r = &Repo{repo: repo}

		return
	}

	func (r *Repo) GetByID(ctx context.Context, id uint64) (*models.UserModel, error) {
		var target models.UserModel
		err := r.repo.Get(ctx, id).Into(&target).Response()

		if err == mgo.ErrNotFound {
			err = ErrNotFound
		}

		return &target, err
	}

	func (r *Repo) Upsert(ctx context.Context, target *models.UserModel) error {
		return r.repo.Put(ctx, target).Response()
	}

	func (r *Repo) DeleteByID(ctx context.Context, id uint64) error {
		return r.repo.Delete(ctx, id).Response()
	}

* Testing

	import (
		models "github.com/lyft/lyft-idl/generated/go/pb/lyft/testsrv"
		repo "github.com/lyft/lyft-idl/generated/go/pb/lyft/testsrv/testsrv/dynamodb"
	)

	func TestRepo_GetByID(t *testing.T) {
		expect := &models.UserModel{Id: 1}
		mock := repo.NewMock(expect, nil)
		r := New(mock)

		got, err := r.GetByID(context.Background(), 1)
		assert.NoError(t, err)
		assert.Equal(t, expect, got)
	}

	func TestRepo_GetByIDNotFound(t *testing.T) {
		mock := repo.NewMock(nil, ErrNotFound)
		r := New(mock)

		got, err := r.GetByID(context.Background(), 1)

		assert.Equal(t, &models.UserModel{}, got)
		assert.Equal(t, ErrNotFound, err)
	}

* Handlers

- Functions bound to each RPC method
- Reduce complexity
- Encourage granular testing

* Handlers

	└── services
		├── drivers
		    ├── config
		    │   └── drivers_config.go
		    ├── drivers_service.go
		    └── grpc
		        └── handlers
		            ├── common.go
		            ├── create_handler.go
		            ├── create_handler_test.go
		            ├── get_from_supply_handler.go
		            ├── get_from_supply_handler_test.go
		            ├── get_handler.go
		            ├── get_handler_test.go
		            ├── package.go
		            ├── update_handler.go
		            └── update_handler_test.go

* Handlers

	var ErrDriverNotFound = grpc.Errorf(codes.NotFound, "driver not found")
	var ErrGetDriverDisabled = grpc.Errorf(codes.Internal, "get driver disabled")

	func Get(cfg *config.DriversConfig) GetDriverHandlerFunc {
		return func(ctx context.Context, req *models.GetDriverRequest) (*models.GetDriverResponse, error) {

			if !cfg.Runtime().FeatureEnabled("get_driver_api") {
				return nil, ErrGetDriverDisabled
			}

			drv, err := cfg.DynamoDbDriverRepo().GetByID(ctx, req.Id)

			if err != nil {
				if err == driver.ErrNotFound {
					return nil, ErrDriverNotFound
				}

				return nil, grpc.Errorf(codes.Internal, err.Error())
			}

			return &models.GetDriverResponse{Driver: drv.ToProto()}, nil
		}
	}

* Testing

	func TestGetDriverHandler(t *testing.T) {
		expected := &models.DriverModel{Id: 1}

		cfg := config.NewMock(expected, nil)
		resp, err := GetDriver(cfg)(context.Background(), &models.GetDriverRequest{Id: 1})

		assert.NoError(t, err)
		assert.Equal(t, expected.Id, resp.Driver.Id.Id)
	}

	func TestGetDriverHandler_NotFound(t *testing.T) {
		cfg := config.NewMock(nil, driver.ErrNotFound)
		resp, err := GetDriver(cfg)(context.Background(), &models.GetDriverRequest{Id: 1})

		assert.Nil(t, resp)
		assert.Equal(t, ErrDriverNotFound, err)
	}

* Sanity checking gRPC

- No cURL
- Binary transport
- Write your own clients

* SRV CLI

	~/Go/src/github.com/lyft/supply → ./cli/cli
	NAME:
	   supply - CLI for the gRPC service

	USAGE:
	   cli [global options] command [command options] [arguments...]

	VERSION:
	   0.0.0

	COMMANDS:
	     GetDriver  ./bin/cli GetDriver '{}'
	     Create     ./bin/cli Create '{}'
	     Update     ./bin/cli Update '{}'
	     Create     ./bin/cli Create '{}'
	     Get        ./bin/cli Get '{}'
	     Update     ./bin/cli Update '{}'
	     help, h    Shows a list of commands or help for one command

	GLOBAL OPTIONS:
	   --help, -h     show help
	   --version, -v  print the version

* Usage

	$ ./cli/cli Create '{"Name": "Christopher"}'
	$ ./cli/cli Get '{"Id": 1}'

What else?

- Full integration tests (Mongo & Dynamo)
- Extensive README docs
- Preconfigured CI and Orca

* Questions?

